# 并发注册问题分析与解决方案

**文档版本**: v1.0  
**创建日期**: 2026-01-05  
**问题级别**: Critical  
**影响范围**: 用户注册模块  

---

## 📋 目录

- [问题概述](#问题概述)
- [问题根因分析](#问题根因分析)
- [解决方案](#解决方案)
- [技术实现](#技术实现)
- [测试验证](#测试验证)
- [经验总结](#经验总结)

---

## 问题概述

### 现象描述

在并发场景下，用户注册接口存在以下问题：

1. **重复数据问题**：多个并发请求可以创建具有相同用户名/邮箱/手机号的用户记录
2. **测试失败**：性能测试中的 `test_duplicate_username_concurrent` 测试用例失败
3. **数据完整性风险**：数据库唯一性约束未能有效发挥作用

### 问题影响

- **数据一致性破坏**：违反业务规则，同一用户名可能对应多个账户
- **安全风险**：可能被恶意利用进行账户抢占攻击
- **用户体验差**：后续登录/查询可能出现异常

### 复现条件

```python
# 5个线程同时尝试注册相同用户名
concurrent_count = 5
test_user = create_mock_user()  # 相同的用户名

with ThreadPoolExecutor(max_workers=concurrent_count) as executor:
    futures = [executor.submit(register_same_user, i) for i in range(concurrent_count)]
```

**预期结果**：只有1个请求成功，其他4个返回冲突错误（409/400）  
**实际结果**：可能有多个请求同时成功创建用户

---

## 问题根因分析

### 根因一：数据库唯一索引设计缺陷 ⚠️

**问题代码**（旧版 `sql/user.sql`）：

```sql
-- ❌ 有问题的索引设计
CREATE UNIQUE INDEX `uk_username_deleted` ON `t_user` (`username`, `deleted_at`);
CREATE UNIQUE INDEX `uk_email_deleted` ON `t_user` (`email`, `deleted_at`);
CREATE UNIQUE INDEX `uk_phone_deleted` ON `t_user` (`phone_country_code`, `phone_number`, `deleted_at`);
```

**根本原因**：

1. **MySQL 的 NULL 特性**：
   - MySQL 将每个 `NULL` 值视为不同的值（这是 SQL 标准的行为：NULL 不等于任何值，包括它自己。）
   - 唯一索引只禁止完全相同的非 NULL 值组合，复合唯一索引 `(username, deleted_at)` 中，当 `deleted_at = NULL` 时，索引无法生效
   - 这意味着可以插入多条 `(username, NULL)` 的记录，被视为“不冲突”

2. **软删除场景冲突**：
   - 设计意图：支持软删除，已删除用户可以有相同的用户名
   - 实际效果：活跃用户（`deleted_at=NULL`）也失去了唯一性约束

**验证实验**：

```sql
-- 实验：尝试插入两条相同 username 且 deleted_at=NULL 的记录
INSERT INTO t_user (id, username, password, phone_country_code, phone_number, deleted_at) 
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'testuser', 'pass1', '+86', '13800000001', NULL);

INSERT INTO t_user (id, username, password, phone_country_code, phone_number, deleted_at) 
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'testuser', 'pass2', '+86', '13800000002', NULL);

-- 结果：两条 INSERT 都成功！❌
```

### 根因二：业务代码 Check-Then-Act 反模式 ⚠️

**问题代码**（旧版 `internal/service/user/register_user.go`）：

```go
// ❌ 反模式：先检查再创建
func (l *RegisterUserService) RegisterUser(req *userDto.RegisterUserReq) {
    txErr := l.svcCtx.Repository.User.Transaction(l.ctx, func(txRepo userRepo.UserRepository) error {
        // 步骤1: 检查用户名是否存在
        exists, err := txRepo.ExistsByUsername(l.ctx, req.Username)
        if exists {
            return ErrUsernameExists
        }
        
        // 步骤2: 创建用户（存在时间窗口！）
        if err := txRepo.Create(l.ctx, user); err != nil {
            return err
        }
        return nil
    })
}
```

**并发竞态条件时序图**：

```
时间轴    线程A                           线程B
---------|-------------------------------|-------------------------------
t1       | ExistsByUsername("alice")     |
t2       | → 返回 false (不存在)           |
t3       |                               | ExistsByUsername("alice")
t4       |                               | → 返回 false (不存在)
t5       | Create("alice")               |
t6       | → 成功 ✓                       |
t7       |                               | Create("alice")
t8       |                               | → 成功 ✓ (问题！应该失败)
```

**根本原因**：

1. **时间窗口漏洞**：检查和创建之间存在时间间隔，其他线程可以在此期间通过检查
2. **数据库事务无法解决**：即使使用事务，Read Committed 隔离级别下仍然存在竞态条件
3. **数据库约束失效**：由于根因一，数据库层面也无法阻止重复插入

### 根因三：错误处理依赖数据库实现细节 ⚠️

**问题代码**（第一版修复尝试）：

```go
// ❌ 硬编码数据库索引名称
if mysqlErr.Number == 1062 {
    msg := strings.ToLower(mysqlErr.Message)
    if strings.Contains(msg, "uk_username_active") {  // 耦合索引名
        return ErrUsernameExists
    }
}
```

**问题**：

1. **强耦合**：业务代码依赖数据库索引名称，违反分层架构原则
2. **脆弱性**：索引重命名后业务代码需要同步修改
3. **可维护性差**：数据库迁移（如切换到 PostgreSQL）时需要大量改动

---

## 解决方案

### 设计原则

1. **数据库层作为最后防线**：唯一索引必须能够真正生效
2. **应用层并发控制**：使用分布式锁序列化关键操作
3. **解耦业务和存储**：避免业务代码依赖数据库实现细节
4. **防御式编程**：多层防护，任何一层失效都不会导致数据损坏

### 解决方案架构

```
┌─────────────────────────────────────────────────────────────┐
│                      用户注册请求                              │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────────┐
         │   Redis 分布式锁（应用层）           │
         │   lock:user:register:{username}     │
         │   - 序列化同用户名的并发请求          │
         │   - TTL: 10s（防止死锁）             │
         └────────────────┬───────────────────┘
                          │ 获取锁成功
                          ▼
         ┌────────────────────────────────────┐
         │   数据库事务（存储层）               │
         │   1. 检查用户名/邮箱/手机号是否存在   │
         │   2. 如果不存在，创建用户记录         │
         │   3. 提交事务                       │
         └────────────────┬───────────────────┘
                          │
                          ▼
         ┌────────────────────────────────────┐
         │   数据库唯一索引（最后防线）          │
         │   uk_username_active                │
         │   uk_email_active                   │
         │   uk_phone_active                   │
         └────────────────────────────────────┘
```

### 三层防护机制

| 层次 | 机制 | 作用 | 失效后果 |
|------|------|------|---------|
| **第一层** | Redis 分布式锁 | 序列化并发请求，减少数据库压力 | 进入第二层验证 |
| **第二层** | 事务内存在性检查 | 在锁保护下再次确认唯一性 | 进入第三层约束 |
| **第三层** | 数据库唯一索引 | 数据库层面强制唯一性约束 | 返回 1062 错误 |

---

## 技术实现

### 实现一：修复数据库唯一索引

**文件**: `sql/user.sql`

```sql
-- ============================================================
-- 唯一性约束索引（仅对活跃用户 deleted_at IS NULL）
-- ============================================================
-- 方案：使用虚拟列方案（兼容 MySQL 5.7+）
-- 原理：IFNULL(deleted_at, 1) 
--   - deleted_at IS NULL（活跃用户）→ 返回固定值 1
--   - deleted_at 不为 NULL（已删除用户）→ 返回不同的时间戳
-- 效果：活跃用户被约束为唯一，已删除用户不受影响

CREATE UNIQUE INDEX `uk_username_active` 
ON `t_user` (`username`, (IFNULL(`deleted_at`, 1)));

CREATE UNIQUE INDEX `uk_email_active` 
ON `t_user` (`email`, (IFNULL(`deleted_at`, 1)));

CREATE UNIQUE INDEX `uk_phone_active` 
ON `t_user` (`phone_country_code`, `phone_number`, (IFNULL(`deleted_at`, 1)));
```

**验证测试**：

```sql
-- 测试1: 创建两个相同 username 的活跃用户（应该失败）
INSERT INTO t_user (id, username, password, phone_country_code, phone_number) 
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'test_user', 'pass1', '+86', '13800000001');

INSERT INTO t_user (id, username, password, phone_country_code, phone_number) 
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'test_user', 'pass2', '+86', '13800000002');
-- ✅ 预期结果：第二条 INSERT 报错 "Duplicate entry"

-- 测试2: 创建两个相同 username 但已删除的用户（应该成功）
INSERT INTO t_user (id, username, password, phone_country_code, phone_number, deleted_at) 
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'deleted_user', 'pass1', '+86', '13800000003', NOW());

INSERT INTO t_user (id, username, password, phone_country_code, phone_number, deleted_at) 
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'deleted_user', 'pass2', '+86', '13800000004', NOW());
-- ✅ 预期结果：两条 INSERT 都成功
```

### 实现二：Redis 分布式锁

**文件**: `infra/cache/lock.go`

**核心功能**：

```go
// 1. 获取锁（使用 SET NX EX 实现原子操作）
func (l *DistributedLock) TryLock(ctx context.Context) (bool, error) {
    success, err := l.client.SetNX(ctx, l.key, l.value, l.ttl).Result()
    return success, err
}

// 2. 释放锁（使用 Lua 脚本保证原子性）
func (l *DistributedLock) Unlock(ctx context.Context) error {
    luaScript := `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
    `
    result, err := l.client.Eval(ctx, luaScript, []string{l.key}, l.value).Result()
    // ...
}

// 3. 便捷函数：自动获取和释放锁
func WithLock(ctx context.Context, client *redis.Client, 
              key, value string, ttl time.Duration, fn func() error) error {
    lock := NewDistributedLock(client, key, value, ttl)
    
    // 获取锁（带重试：5次，间隔50ms）
    if err := lock.Lock(ctx, 5, 50*time.Millisecond); err != nil {
        return err
    }
    
    defer lock.Unlock(context.Background())
    
    // 执行业务逻辑
    return fn()
}
```

**关键设计点**：

1. **原子性保证**：
   - 获取锁使用 `SET NX EX`，一条命令完成"检查-设置-过期"
   - 释放锁使用 Lua 脚本，保证"检查-删除"的原子性

2. **防止误删**：
   - 每个锁有唯一的 value（UUID）
   - 释放时验证 value，只能释放自己持有的锁

3. **死锁预防**：
   - 设置 TTL（10秒），即使程序崩溃也会自动释放
   - defer 确保锁一定会被释放

4. **重试机制**：
   - 失败后重试 5 次，间隔 50ms
   - 总等待时间约 250ms，平衡响应速度和并发冲突

### 实现三：重构注册逻辑

**文件**: `internal/service/user/register_user.go`

```go
func (l *RegisterUserService) RegisterUser(req *userDto.RegisterUserReq) (resp *userDto.RegisterUserResp, err error) {
    // 1. 加密密码（事务外处理）
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, fmt.Errorf("failed to hash password: %v", err)
    }

    // 2. 定义锁参数
    lockKey := fmt.Sprintf("lock:user:register:%s", req.Username)
    lockValue := uuid.New().String()
    lockTTL := 10 * time.Second

    // 3. 在 Redis 锁保护下执行注册逻辑
    err = cache.WithLock(l.ctx, l.svcCtx.Cache.RedisClient, lockKey, lockValue, lockTTL, func() error {
        return l.svcCtx.Repository.User.Transaction(l.ctx, func(txRepo userRepo.UserRepository) error {
            // 3.1 检查用户名是否存在
            exists, err := txRepo.ExistsByUsername(l.ctx, req.Username)
            if err != nil {
                return fmt.Errorf("failed to check username existence: %w", err)
            }
            if exists {
                return ErrUsernameExists
            }

            // 3.2 检查邮箱是否存在
            if req.Email != "" {
                existingUser, err := txRepo.GetByEmail(l.ctx, req.Email)
                if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
                    return fmt.Errorf("failed to check email existence: %w", err)
                }
                if existingUser != nil {
                    return ErrEmailExists
                }
            }

            // 3.3 检查手机号是否存在
            exists, err = txRepo.ExistsByPhone(l.ctx, req.PhoneCountryCode, req.PhoneNumber)
            if err != nil {
                return fmt.Errorf("failed to check phone existence: %w", err)
            }
            if exists {
                return ErrPhoneExists
            }

            // 3.4 创建用户
            user := &userEntity.User{
                Username:         req.Username,
                Password:         string(hashedPassword),
                Email:            req.Email,
                PhoneCountryCode: req.PhoneCountryCode,
                PhoneNumber:      req.PhoneNumber,
                Nickname:         req.Nickname,
                Status:           userConstant.StatusActive,
            }

            if err := txRepo.Create(l.ctx, user); err != nil {
                // 3.5 处理极端情况：数据库约束失效
                if mysqlErr, ok := err.(*mysql.MySQLError); ok && mysqlErr.Number == 1062 {
                    // 再次查询确定冲突字段（不依赖索引名）
                    if exists, _ := txRepo.ExistsByUsername(l.ctx, req.Username); exists {
                        return ErrUsernameExists
                    }
                    if req.Email != "" {
                        if u, _ := txRepo.GetByEmail(l.ctx, req.Email); u != nil {
                            return ErrEmailExists
                        }
                    }
                    if exists, _ := txRepo.ExistsByPhone(l.ctx, req.PhoneCountryCode, req.PhoneNumber); exists {
                        return ErrPhoneExists
                    }
                    return errors.New("user already exists")
                }
                return fmt.Errorf("failed to create user: %w", err)
            }

            return nil
        })
    })

    if err != nil {
        return nil, err
    }

    return &userDto.RegisterUserResp{}, nil
}
```

**关键改进点**：

1. **✅ 使用 Redis 锁序列化请求**：避免并发冲突
2. **✅ 锁内执行存在性检查**：在保护下进行 Check-Then-Act
3. **✅ 解耦错误处理**：通过再次查询确定冲突字段，不依赖索引名
4. **✅ 三层防护**：锁 + 检查 + 数据库约束

---

## 测试验证

### 测试用例

**文件**: `test/user/test_register_user.py`

```python
def test_duplicate_username_concurrent(self, go_server, api_client):
    """测试并发创建相同用户名（验证数据库唯一性约束）"""
    concurrent_count = 5
    test_user = create_mock_user()  # 相同的用户名
    
    success_count = 0
    conflict_count = 0
    
    def register_same_user(index: int):
        """尝试注册相同用户名"""
        try:
            response = UserRequest.create_user(api_client, test_user)
            return {"index": index, "status_code": response.status_code}
        except Exception as e:
            return {"index": index, "error": str(e)}
    
    logger.info(f"测试并发注册相同用户名: {test_user.username}")
    
    with ThreadPoolExecutor(max_workers=concurrent_count) as executor:
        futures = [executor.submit(register_same_user, i) for i in range(concurrent_count)]
        
        for future in as_completed(futures):
            result = future.result()
            status = result.get("status_code")
            if status == 200:
                success_count += 1
            elif status in [409, 400]:
                conflict_count += 1
    
    logger.info(f"并发重复注册结果: 成功 {success_count}, 冲突 {conflict_count}")
    
    # 验证：应该只有一个成功，其他都返回冲突
    assert success_count == 1, f"应该只有1个注册成功，实际: {success_count}"
    assert conflict_count >= concurrent_count - 1, (
        f"其他请求应该返回冲突，实际冲突数: {conflict_count}"
    )
    logger.success("✓ 数据库唯一性约束在并发场景下正常工作")
```

### 测试结果

**修复前**：

```
并发重复注册结果: 成功 3, 冲突 2
FAILED - AssertionError: 应该只有1个注册成功，实际: 3
```

**修复后**：

```
并发重复注册结果: 成功 1, 冲突 4
✓ 数据库唯一性约束在并发场景下正常工作
PASSED
```

### 性能测试

```python
def test_concurrent_registration(self, go_server, api_client):
    """测试并发注册（验证性能和竞态条件）"""
    concurrent_users = 10
    # ... 省略实现
    
    # 结果示例
    logger.info(f"并发注册完成: 成功 10/10, 失败 0/10")
    logger.info(f"总耗时: 523.45ms, 平均每个用户: 52.35ms")
    logger.success("✓ 并发注册测试通过，成功率: 100.0%")
```

---

## 经验总结

### 技术要点

1. **数据库约束设计**
   - ⚠️ MySQL 中 `NULL` 不参与唯一性比较
   - ✅ 使用虚拟列 `IFNULL(deleted_at, 1)` 解决软删除场景下的唯一性约束
   - ✅ 或使用 MySQL 8.0+ 的函数索引 `WHERE deleted_at IS NULL`

2. **并发控制策略**
   - ❌ 避免 Check-Then-Act 反模式
   - ✅ 使用分布式锁序列化关键操作
   - ✅ 数据库约束作为最后防线

3. **错误处理原则**
   - ❌ 避免业务代码依赖存储层实现细节（如索引名）
   - ✅ 通过再次查询确定冲突字段
   - ✅ 保持各层职责清晰

4. **分布式锁最佳实践**
   - ✅ 使用 `SET NX EX` 实现原子操作
   - ✅ 锁带唯一标识，防止误删
   - ✅ 设置 TTL 防止死锁
   - ✅ Lua 脚本保证释放锁的原子性

### 架构原则

1. **纵深防御（Defense in Depth）**
   - 应用层：Redis 分布式锁
   - 业务层：事务内存在性检查
   - 存储层：数据库唯一索引
   - 任何一层失效都不会导致数据损坏

2. **解耦与分层**
   - 业务代码不应依赖存储实现细节
   - 通过接口和抽象隔离各层
   - 便于后续迁移和扩展

3. **性能与安全平衡**
   - Redis 锁增加了约 50ms 延迟
   - 换来了数据一致性保证
   - 对于注册场景，这是可接受的权衡

### 推荐阅读

- [MySQL 8.0 Reference Manual - Unique Indexes](https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-unique)
- [Redis 分布式锁的正确实现方式](https://redis.io/topics/distlock)
- [OWASP - Race Conditions](https://owasp.org/www-community/vulnerabilities/Race_Conditions)
- [Designing Data-Intensive Applications](https://dataintensive.net/) - Chapter 7: Transactions

---

## 附录

### 相关文件清单

| 文件路径 | 修改类型 | 说明 |
|---------|---------|------|
| `sql/user.sql` | 修改 | 修复数据库唯一索引 |
| `infra/cache/lock.go` | 新增 | Redis 分布式锁实现 |
| `internal/service/user/register_user.go` | 重构 | 优化注册逻辑 |
| `test/user/test_register_user.py` | 新增 | 并发测试用例 |
| `docs/CONCURRENT_REGISTRATION_FIX.md` | 新增 | 本文档 |

### 回滚方案

如果需要回滚到旧版本：

```bash
# 1. 回滚数据库索引
mysql -h mysql -P 3306 -u root -p < sql/rollback_indexes.sql

# 2. 回滚代码
git revert <commit-hash>

# 3. 重启服务
make restart
```

### 监控指标

建议添加以下监控指标：

1. **Redis 锁获取成功率**：`lock_acquire_success_rate`
2. **Redis 锁等待时间**：`lock_wait_duration_ms`
3. **数据库唯一性冲突次数**：`db_duplicate_entry_count`
4. **注册接口响应时间**：`register_api_response_time_ms`

---

**文档结束**

如有疑问，请联系：开发团队 / 架构组
